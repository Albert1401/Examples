{
open Calc.AST
}

tokens {
    _ of string
}

options {
    translate = true
    module = "Calc.Parser"
    infEpsPath = epsilons
    pos = uint64
}

module Main

[<Start>]
program: (stmt SEMI)+

stmt:
   v=VAR EQ e=expr {
   let getValue e = match e with
   | Num num -> num
   | BinOp (op,l,r,result) -> result
   | EVar (name) -> vars.[name]

   let result = getValue(e)

   let ok, item = vars.TryGetValue(v)
   if (ok) then
     vars.[v] <- result
   else
     vars.Add(v, result)
   EqStmt(v, e)
   }

   | e=expr {SingleExpr(e)}

binExpr<operand binOp>: h=operand tl=(binOp operand)* {

let getValue e = match e with
   | Num num -> num
   | BinOp (op,l,r,result) -> result
   | EVar (name) -> vars.[name]

let calcFunc l (op, r) =
   let result = match op with
   | Plus  -> getValue l + getValue r
   | Minus -> getValue l - getValue r
   | Mult  -> getValue l * getValue r
   | Div   -> getValue l / getValue r
   | Pow   -> getValue l ** getValue r
   BinOp(op,l,r, result)

List.fold calcFunc h tl
}

expr: binExpr<term termOp>

termOp: PLUS {Plus} | MINUS {Minus}

term: binExpr<factor factorOp>

factorOp: MULT {Mult} | DIV {Div}

factor: binExpr<powExpr powOp>

powOp: POW {Pow}

powExpr:
   n=NUMBER {Num (float n)}
   | v=VAR {EVar(v)}
   | LBRACE e=expr RBRACE {e}

